// Generated by Qodo Gen

describe('getAllOrders', () => {

    // Successfully retrieves all non-deleted orders with populated fields
    it('should return all non-deleted orders with populated fields and status 200', async () => {
      // Mock data
      const mockOrders = [
        { id: '1', customer_id: { firstName: 'John', lastName: 'Doe', email: 'john@example.com', phone: '1234567890' } },
        { id: '2', customer_id: { firstName: 'Jane', lastName: 'Smith', email: 'jane@example.com', phone: '0987654321' } }
      ];
  
      // Mock request and response
      const req = {};
      const res = {
        status: jest.fn().mockReturnThis(),
        json: jest.fn()
      };
  
      // Mock Order.find and populate methods
      const populateStub = {
        populate: jest.fn().mockReturnThis()
      };
  
      for (let i = 0; i < 5; i++) {
        populateStub.populate = jest.fn().mockReturnThis();
      }
  
      populateStub.populate.mockResolvedValue(mockOrders);
  
      db.Order = {
        find: jest.fn().mockReturnValue(populateStub)
      };
  
      // Call the function
      await getAllOrders(req, res);
  
      // Assertions
      expect(db.Order.find).toHaveBeenCalledWith({ is_delete: false });
      expect(res.status).toHaveBeenCalledWith(200);
      expect(res.json).toHaveBeenCalledWith(mockOrders);
    });

    // Handles case when no orders exist in the database
    it('should return empty array when no orders exist in the database', async () => {
      // Mock request and response
      const req = {};
      const res = {
        status: jest.fn().mockReturnThis(),
        json: jest.fn()
      };
  
      // Mock Order.find and populate methods
      const populateStub = {
        populate: jest.fn().mockReturnThis()
      };
  
      for (let i = 0; i < 5; i++) {
        populateStub.populate = jest.fn().mockReturnThis();
      }
  
      populateStub.populate.mockResolvedValue([]);
  
      db.Order = {
        find: jest.fn().mockReturnValue(populateStub)
      };
  
      // Call the function
      await getAllOrders(req, res);
  
      // Assertions
      expect(db.Order.find).toHaveBeenCalledWith({ is_delete: false });
      expect(res.status).toHaveBeenCalledWith(200);
      expect(res.json).toHaveBeenCalledWith([]);
    });
});

// Generated by Qodo Gen

describe('getOrderById', () => {

    // Successfully retrieves an order by ID with all populated fields
    it('should return order and order details when order exists', async () => {
      // Arrange
      const mockOrder = {
        _id: 'order123',
        customer_id: {
          firstName: 'John',
          lastName: 'Doe',
          email: 'john@example.com',
          phone: '1234567890'
        },
        shipping_id: { method: 'Express' },
        payment_id: { method: 'Credit Card' },
        discount_id: { amount: 10 },
        coupon_id: { code: 'SAVE10' },
        user_address_id: { address: '123 Main St' }
      };
  
      const mockOrderDetails = [
        { 
          order_id: 'order123', 
          product_id: { name: 'Product 1' }, 
          discount_id: { amount: 5 } 
        }
      ];
  
      const req = { params: { id: 'order123' } };
      const res = {
        status: jest.fn().mockReturnThis(),
        json: jest.fn()
      };
  
      Order.findById = jest.fn().mockReturnThis();
      Order.populate = jest.fn().mockReturnThis();
      Order.findById().populate = jest.fn().mockReturnThis();
      Order.findById().populate().populate = jest.fn().mockReturnThis();
      Order.findById().populate().populate().populate = jest.fn().mockReturnThis();
      Order.findById().populate().populate().populate().populate = jest.fn().mockReturnThis();
      Order.findById().populate().populate().populate().populate().populate = jest.fn().mockReturnThis();
      Order.findById().populate().populate().populate().populate().populate().populate = jest.fn().mockResolvedValue(mockOrder);
  
      OrderDetail.find = jest.fn().mockReturnThis();
      OrderDetail.find().populate = jest.fn().mockReturnThis();
      OrderDetail.find().populate().populate = jest.fn().mockResolvedValue(mockOrderDetails);
  
      // Act
      await getOrderById(req, res);
  
      // Assert
      expect(Order.findById).toHaveBeenCalledWith('order123');
      expect(OrderDetail.find).toHaveBeenCalledWith({ order_id: 'order123' });
      expect(res.status).toHaveBeenCalledWith(200);
      expect(res.json).toHaveBeenCalledWith({ order: mockOrder, orderDetails: mockOrderDetails });
    });

    // Order with the given ID does not exist
    it('should return 404 when order does not exist', async () => {
      // Arrange
      const req = { params: { id: 'nonexistentId' } };
      const res = {
        status: jest.fn().mockReturnThis(),
        json: jest.fn()
      };
  
      Order.findById = jest.fn().mockReturnThis();
      Order.populate = jest.fn().mockReturnThis();
      Order.findById().populate = jest.fn().mockReturnThis();
      Order.findById().populate().populate = jest.fn().mockReturnThis();
      Order.findById().populate().populate().populate = jest.fn().mockReturnThis();
      Order.findById().populate().populate().populate().populate = jest.fn().mockReturnThis();
      Order.findById().populate().populate().populate().populate().populate = jest.fn().mockReturnThis();
      Order.findById().populate().populate().populate().populate().populate().populate = jest.fn().mockResolvedValue(null);
  
      // Act
      await getOrderById(req, res);
  
      // Assert
      expect(Order.findById).toHaveBeenCalledWith('nonexistentId');
      expect(res.status).toHaveBeenCalledWith(404);
      expect(res.json).toHaveBeenCalledWith({ message: "Order not found" });
      expect(OrderDetail.find).not.toHaveBeenCalled();
    });
});

// Generated by Qodo Gen

describe('getOrdersByUserId', () => {

    // Returns orders for a valid user ID with status 200
    it('should return orders with status 200 when valid user ID is provided', async () => {
      // Arrange
      const req = {
        params: {
          userId: 'validUserId'
        }
      };
  
      const res = {
        status: jest.fn().mockReturnThis(),
        json: jest.fn()
      };
  
      const mockOrders = [
        { id: 'order1', customer_id: 'validUserId' },
        { id: 'order2', customer_id: 'validUserId' }
      ];
  
      const mockFind = jest.fn().mockReturnThis();
      const mockPopulate = jest.fn().mockReturnThis();
      const mockSort = jest.fn().mockResolvedValue(mockOrders);
  
      jest.spyOn(db.Order, 'find').mockImplementation(() => ({
        populate: mockPopulate,
        sort: mockSort
      }));
  
      // Act
      await getOrdersByUserId(req, res);
  
      // Assert
      expect(db.Order.find).toHaveBeenCalledWith({
        customer_id: 'validUserId',
        is_delete: false
      });
      expect(res.status).toHaveBeenCalledWith(200);
      expect(res.json).toHaveBeenCalledWith(mockOrders);
    });

    // Handles non-existent user ID by returning empty array
    it('should return empty array when user ID does not exist', async () => {
      // Arrange
      const req = {
        params: {
          userId: 'nonExistentUserId'
        }
      };
  
      const res = {
        status: jest.fn().mockReturnThis(),
        json: jest.fn()
      };
  
      const mockEmptyOrders = [];
  
      const mockFind = jest.fn().mockReturnThis();
      const mockPopulate = jest.fn().mockReturnThis();
      const mockSort = jest.fn().mockResolvedValue(mockEmptyOrders);
  
      jest.spyOn(db.Order, 'find').mockImplementation(() => ({
        populate: mockPopulate,
        sort: mockSort
      }));
  
      // Act
      await getOrdersByUserId(req, res);
  
      // Assert
      expect(db.Order.find).toHaveBeenCalledWith({
        customer_id: 'nonExistentUserId',
        is_delete: false
      });
      expect(res.status).toHaveBeenCalledWith(200);
      expect(res.json).toHaveBeenCalledWith(mockEmptyOrders);
    });
});

// Generated by Qodo Gen

describe('createOrder', () => {

    // Successfully creating an order with valid order items
    it('should create a new order and return 201 status when valid order items are provided', async () => {
      // Mock request and response
      const req = {
        body: {
          customer_id: 'customer123',
          shipping_id: 'shipping123',
          payment_id: 'payment123',
          order_payment_id: 'orderPayment123',
          user_address_id: 'address123',
          orderItems: [
            { product_id: 'product123', quantity: 2, cart_id: 'cart123' }
          ]
        }
      };
  
      const res = {
        status: jest.fn().mockReturnThis(),
        json: jest.fn()
      };
  
      // Mock Product model
      const mockProduct = {
        _id: { toString: () => 'product123' },
        name: 'Test Product',
        price: 100,
        stock: 10,
        category_id: 'category123',
        save: jest.fn().mockResolvedValue(true)
      };
  
      Product.findById = jest.fn().mockResolvedValue(mockProduct);
  
      // Mock Order model
      const mockSavedOrder = {
        _id: 'order123',
        customer_id: 'customer123',
        total_price: 200
      };
  
      Order.prototype.save = jest.fn().mockResolvedValue(mockSavedOrder);
  
      // Mock OrderDetail model
      const mockSavedOrderDetail = {
        id: 'OD-123',
        order_id: 'order123',
        product_id: 'product123',
        quantity: 2,
        price: 100
      };
  
      OrderDetail.prototype.save = jest.fn().mockResolvedValue(mockSavedOrderDetail);
  
      // Execute the function
      await createOrder(req, res);
  
      // Assertions
      expect(res.status).toHaveBeenCalledWith(201);
      expect(res.json).toHaveBeenCalledWith(
        expect.objectContaining({
          message: "Order created successfully",
          order: mockSavedOrder,
          orderDetails: [mockSavedOrderDetail]
        })
      );
  
      // Verify product stock was updated
      expect(mockProduct.stock).toBe(8);
      expect(mockProduct.save).toHaveBeenCalled();
    });

    // Creating an order with empty order items
    it('should return 400 status when order items are empty', async () => {
      // Mock request with empty order items
      const req = {
        body: {
          customer_id: 'customer123',
          shipping_id: 'shipping123',
          payment_id: 'payment123',
          order_payment_id: 'orderPayment123',
          user_address_id: 'address123',
          orderItems: []
        }
      };
  
      // Mock request with no order items
      const reqNoItems = {
        body: {
          customer_id: 'customer123',
          shipping_id: 'shipping123',
          payment_id: 'payment123',
          order_payment_id: 'orderPayment123',
          user_address_id: 'address123'
        }
      };
  
      const res = {
        status: jest.fn().mockReturnThis(),
        json: jest.fn()
      };
  
      // Test with empty array
      await createOrder(req, res);
  
      // Assertions for empty array
      expect(res.status).toHaveBeenCalledWith(400);
      expect(res.json).toHaveBeenCalledWith({ message: "No order items" });
  
      // Reset mocks
      res.status.mockClear();
      res.json.mockClear();
  
      // Test with undefined orderItems
      await createOrder(reqNoItems, res);
  
      // Assertions for undefined orderItems
      expect(res.status).toHaveBeenCalledWith(400);
      expect(res.json).toHaveBeenCalledWith({ message: "No order items" });
    });
});
